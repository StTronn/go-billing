// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: event.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countEventsByCustomerIdAndCode = `-- name: CountEventsByCustomerIdAndCode :one
SELECT customer_id, code, COUNT(*) AS count
FROM event
WHERE customer_id = ? AND code = ?
GROUP BY customer_id, code
`

type CountEventsByCustomerIdAndCodeParams struct {
	CustomerID string
	Code       string
}

type CountEventsByCustomerIdAndCodeRow struct {
	CustomerID string
	Code       string
	Count      int64
}

func (q *Queries) CountEventsByCustomerIdAndCode(ctx context.Context, arg CountEventsByCustomerIdAndCodeParams) (CountEventsByCustomerIdAndCodeRow, error) {
	row := q.db.QueryRowContext(ctx, countEventsByCustomerIdAndCode, arg.CustomerID, arg.Code)
	var i CountEventsByCustomerIdAndCodeRow
	err := row.Scan(&i.CustomerID, &i.Code, &i.Count)
	return i, err
}

const createEvent = `-- name: CreateEvent :execresult
INSERT INTO event (customer_id, code, timestamp, value)
VALUES (?, ?, ?, ?)
`

type CreateEventParams struct {
	CustomerID string
	Code       string
	Timestamp  time.Time
	Value      float64
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEvent,
		arg.CustomerID,
		arg.Code,
		arg.Timestamp,
		arg.Value,
	)
}

const getEventById = `-- name: GetEventById :many
SELECT id, customer_id, code, timestamp, value
FROM event
WHERE id = ?
`

func (q *Queries) GetEventById(ctx context.Context, id int32) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Code,
			&i.Timestamp,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumEventsByCustomerIdAndCodeName = `-- name: SumEventsByCustomerIdAndCodeName :one
SELECT customer_id, code, CAST(SUM(value) AS FLOAT) AS sum
FROM event
WHERE customer_id = ? AND code = ?
GROUP BY customer_id, code
`

type SumEventsByCustomerIdAndCodeNameParams struct {
	CustomerID string
	Code       string
}

type SumEventsByCustomerIdAndCodeNameRow struct {
	CustomerID string
	Code       string
	Sum        float64
}

func (q *Queries) SumEventsByCustomerIdAndCodeName(ctx context.Context, arg SumEventsByCustomerIdAndCodeNameParams) (SumEventsByCustomerIdAndCodeNameRow, error) {
	row := q.db.QueryRowContext(ctx, sumEventsByCustomerIdAndCodeName, arg.CustomerID, arg.Code)
	var i SumEventsByCustomerIdAndCodeNameRow
	err := row.Scan(&i.CustomerID, &i.Code, &i.Sum)
	return i, err
}
